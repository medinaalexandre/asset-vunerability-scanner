<?php

use App\Dto\CveDetailsDto;
use App\Dto\CveDetailsMetricDto;
use App\Enums\VulnerabilitySeverityEnum;
use App\Exceptions\CveIdNotFoundException;
use App\Models\Vulnerability;
use App\Models\VulnerabilityDetail;
use App\Repositories\EloquentVulnerabilityDetailRepository;
use App\Repositories\EloquentVulnerabilityRepository;
use App\Services\Contracts\EnrichCveDetailsServiceInterface;
use App\UseCases\Vulnerability\EnrichVulnerabilityUseCase;
use Carbon\Carbon;
use Illuminate\Database\Eloquent\ModelNotFoundException;

beforeEach(function () {
    $this->apiServiceMock = Mockery::mock(EnrichCveDetailsServiceInterface::class);

    $this->useCase = new EnrichVulnerabilityUseCase(
        $this->apiServiceMock,
        new EloquentVulnerabilityRepository(new Vulnerability()),
        new EloquentVulnerabilityDetailRepository(new VulnerabilityDetail()),
    );
});

it('should throw ModelNotFound if receive an invalid vulnerabilityId', function () {
    $this->useCase->execute(1);
})->throws(ModelNotFoundException::class);


it('should set vulnerability to UNKNOWN severity and return if cve is not found at service', function () {
    $vulnerability = Vulnerability::factory()->create();
    $now = Carbon::now();
    Carbon::setTestNow($now);

    $this->apiServiceMock->shouldReceive('getDetails')
        ->with($vulnerability->cve_id)
        ->once()
        ->andThrow(new CveIdNotFoundException($vulnerability->cve_id));

    $this->useCase->execute($vulnerability->id);

    $vulnerability->refresh();

    expect($vulnerability->severity)->toBe(VulnerabilitySeverityEnum::UNKNOWN)
        ->and($vulnerability->description)->toBe("CVE-ID $vulnerability->cve_id not found")
        ->and($vulnerability->published_at)->toBe($now->toDateTimeString());
});


it('should update vulnerability and upsert details if service respond with a valid Dto', function () {
    $originalPublishedAt = Carbon::parse('2025-10-18T07:15:33.663Z');
    $expectedDescription = 'The vulnerability description.';
    $expectedSourceIdentifier = 'security@wordfence.com';

    $vulnerability = Vulnerability::factory()->create();

    $metricCritical = new CveDetailsMetricDto(
        cvssVersionSource: 'v31',
        metricTypeQualifier: 'Primary',
        source: $expectedSourceIdentifier,
        version: '3.1',
        baseScore: 9.8,
        baseSeverity: 'CRITICAL',
        vector: ''
    );

    $detailsDto = new CveDetailsDto(
        id: $vulnerability->cve_id,
        sourceIdentifier: $expectedSourceIdentifier,
        publishedAt: $originalPublishedAt->toIso8601String(),
        lastModifiedAt: Carbon::now()->toIso8601String(),
        status: 'ANALYZED',
        description: $expectedDescription,
        cweId: 'CWE-79',
        metrics: [$metricCritical],
        references: [],
    );

    $this->apiServiceMock->shouldReceive('getDetails')
        ->with($vulnerability->cve_id)
        ->once()
        ->andReturn($detailsDto);

    $this->useCase->execute($vulnerability->id);

    $vulnerability->refresh();
    $metric = $vulnerability->details[0];
    expect($vulnerability->severity)->toBe(VulnerabilitySeverityEnum::CRITICAL)
        ->and($vulnerability->description)->toBe($expectedDescription)
        ->and($vulnerability->published_at)->toBe($originalPublishedAt->toDateTimeString())
        ->and($vulnerability->details)->count()->toBe(1)
        ->and($metric->source_name)->toBe($expectedSourceIdentifier)
        ->and($metric->base_score)->toBe($metricCritical->baseScore)
        ->and($metric->base_severity)->toBe($metricCritical->baseSeverity)
        ->and($metric->cvss_version)->toBe($metricCritical->cvssVersionSource);
});
