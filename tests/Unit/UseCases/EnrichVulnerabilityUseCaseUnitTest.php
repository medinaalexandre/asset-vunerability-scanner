<?php

use App\Dto\CveDetailsDto;
use App\Dto\CveDetailsMetricDto;
use App\Enums\VulnerabilitySeverityEnum;
use App\Exceptions\CveIdNotFoundException;
use App\Models\Vulnerability;
use App\Repositories\Contracts\VulnerabilityDetailRepositoryInterface;
use App\Repositories\Contracts\VulnerabilityRepositoryInterface;
use App\Services\Contracts\EnrichCveDetailsServiceInterface;
use App\UseCases\Vulnerability\EnrichVulnerabilityUseCase;
use Carbon\Carbon;
use Illuminate\Database\Eloquent\ModelNotFoundException;
use Illuminate\Support\Facades\DB;

beforeEach(function () {
    $this->apiServiceMock = Mockery::mock(EnrichCveDetailsServiceInterface::class);
    $this->vulnerabilityRepositoryMock = Mockery::mock(VulnerabilityRepositoryInterface::class);
    $this->vulnerabilityDetailRepositoryMock = Mockery::mock(VulnerabilityDetailRepositoryInterface::class);
    $this->useCase = new EnrichVulnerabilityUseCase(
        $this->apiServiceMock,
        $this->vulnerabilityRepositoryMock,
        $this->vulnerabilityDetailRepositoryMock
    );
});

it('should vulnerability to severity unknow if cve is not found at service', function () {
    $cveId = 'CVE-2025-0002';
    $vulnerability = new Vulnerability();
    $vulnerability->id = 1;
    $vulnerability->cve_id = $cveId;
    $now = Carbon::now();
    Carbon::setTestNow($now);

    $this->vulnerabilityRepositoryMock->shouldReceive('find')
        ->with($vulnerability->id)
        ->once()
        ->andReturn($vulnerability);

    $this->apiServiceMock->shouldReceive('getDetails')
        ->with($cveId)
        ->once()
        ->andThrow(new CveIdNotFoundException($cveId, new Exception()));

    $this->vulnerabilityRepositoryMock->shouldReceive('update')
        ->with(
            $vulnerability->id,
            VulnerabilitySeverityEnum::UNKNOWN,
            0.0,
            "CVE-ID $cveId not found",
            Mockery::on(static fn (Carbon $mock) => $mock->timestamp === $now->timestamp)
        )->once();

    $this->useCase->execute($vulnerability->id);
});

it('should throw ModelNotFound if receive an invalid vulnerabilityId', function () {
    $this->vulnerabilityRepositoryMock->shouldReceive('find')
        ->with(1)
        ->once()
        ->andReturnNull();

    $this->useCase->execute(1);
})->throws(ModelNotFoundException::class);

it('should update vulnerability and upsert details if service respond with a valid Dto', function () {
    $vulnerabilityId = 1;
    $cveId = 'CVE-2025-0003';
    $originalPublishedAt = Carbon::parse('2025-10-18T07:15:33.663Z');
    $now = Carbon::now();
    Carbon::setTestNow($now);

    $vulnerability = new Vulnerability();
    $vulnerability->id = $vulnerabilityId;
    $vulnerability->cve_id = $cveId;
    $vulnerability->published_at = $originalPublishedAt->toDateTimeString();

    $metricCritical = new CveDetailsMetricDto(
        cvssVersionSource: 'cvssMetricV31',
        metricTypeQualifier: 'Primary',
        source: 'nvd.nist.gov',
        version: '3.1',
        baseScore: 9.8,
        baseSeverity: 'CRITICAL',
        vector: 'AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H'
    );

    $metricMedium = new CveDetailsMetricDto(
        cvssVersionSource: 'cvssMetricV20',
        metricTypeQualifier: 'Primary',
        source: 'nvd.nist.gov',
        version: '2.0',
        baseScore: 6.0,
        baseSeverity: 'MEDIUM',
        vector: 'AV:N/AC:L/Au:N/C:P/I:P/A:P'
    );

    $expectedDescription = 'The WPBakery Page Builder vulnerability.';
    $expectedSourceIdentifier = 'security@wordfence.com';

    $detailsDto = new CveDetailsDto(
        id: $cveId,
        sourceIdentifier: $expectedSourceIdentifier,
        publishedAt: $originalPublishedAt->toIso8601String(),
        lastModifiedAt: $now->toIso8601String(),
        status: 'ANALYZED',
        description: $expectedDescription,
        cweId: 'CWE-79',
        metrics: [$metricCritical, $metricMedium],
        references: [],
    );

    DB::shouldReceive('beginTransaction')->once();
    DB::shouldReceive('commit')->once();
    DB::shouldReceive('rollback')->never();

    $this->vulnerabilityRepositoryMock->shouldReceive('find')
        ->with($vulnerabilityId)
        ->once()
        ->andReturn($vulnerability);

    $this->apiServiceMock->shouldReceive('getDetails')
        ->with($cveId)
        ->once()
        ->andReturn($detailsDto);

    $this->vulnerabilityRepositoryMock->shouldReceive('update')
        ->with(
            $vulnerabilityId,
            VulnerabilitySeverityEnum::CRITICAL,
            9.8,
            $expectedDescription,
            Mockery::on(static fn (Carbon $mock) => $mock->timestamp === $originalPublishedAt->timestamp)
        )
        ->once();

    $this->vulnerabilityDetailRepositoryMock->shouldReceive('upsert')
        ->with($vulnerabilityId, $metricCritical)
        ->once();

    $this->vulnerabilityDetailRepositoryMock->shouldReceive('upsert')
        ->with($vulnerabilityId, $metricMedium)
        ->once();

    $this->useCase->execute($vulnerabilityId);
});
